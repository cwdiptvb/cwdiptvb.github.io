<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Channel catalog editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f1216; --panel:#171b22; --card:#1c2129; --text:#e6e6e6;
      --muted:#a9b0bd; --accent:#4f9cf4; --accent-2:#22c55e; --danger:#ef4444;
      --warning:#f59e0b; --border:#2a313b; }
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,sans-serif;}
    header{background:var(--panel);border-bottom:1px solid var(--border);padding:12px 16px;
      display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;}
    header .title{font-size:18px;font-weight:600;}
    header .actions{display:flex;gap:8px;flex-wrap:wrap;}
    .btn{padding:8px 12px;border:1px solid var(--border);background:var(--card);
      color:var(--text);border-radius:8px;cursor:pointer;font-weight:600;}
    .btn.accent{background:var(--accent);color:#0b1a2b;border-color:transparent;}
    .btn.success{background:var(--accent-2);color:#0b1a2b;border-color:transparent;}
    .btn.warn{background:var(--warning);color:#1a1202;border-color:transparent;}
    .btn.danger{background:var(--danger);color:#2b0b0b;border-color:transparent;}
    .btn:disabled{opacity:.6;cursor:not-allowed;}
    main{padding:16px;}
    .cards{display:grid;grid-template-columns:repeat(auto-fill,minmax(380px,1fr));gap:12px;}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px;}
    .card.selected{outline:2px solid var(--accent);}
    .card.proxy-on{border-color:var(--accent-2);}
    .top{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;margin-bottom:8px;}
    .badge{font-size:12px;padding:3px 8px;border-radius:999px;background:var(--panel);border:1px solid var(--border);color:var(--muted);}
    .grid{display:grid;gap:8px;}
    .row{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;}
    .row input{width:100%;padding:8px;border-radius:8px;border:1px solid var(--border);background:var(--panel);color:var(--text);}
    .checkbox{display:inline-flex;align-items:center;gap:6px;color:var(--muted);}
    .footer-actions{display:flex;gap:8px;margin-top:12px;}
    .log-overlay,.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:100;}
    .log,.modal{background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;width:min(520px,92vw);max-height:80vh;overflow:auto;}
    .log pre{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:8px;color:var(--muted);white-space:pre-wrap;}
  </style>
</head>
<body>
  <header>
    <div class="title">Channel catalog editor</div>
    <div class="actions">
      <button class="btn accent" id="loadBtn">Reload</button>
      <button class="btn success" id="saveBtn" disabled>Save to GitHub</button>
      <button class="btn warn" id="importBtn">Import M3U</button>
      <button class="btn" id="batchBtn" disabled>Batch edit</button>
      <button class="btn" id="addBtn">Add channel</button>
      <button class="btn danger" id="deleteBtn" disabled>Delete Selected</button>
      <button class="btn" id="selectAllBtn">Select: ☐</button>
    </div>
  </header>
  <main>
    <section class="cards" id="cards"></section>
  </main>

  <!-- Deployment log -->
  <div class="log-overlay" id="logOverlay">
    <div class="log">
      <h3>Deployment log</h3>
      <pre id="logPre"></pre>
      <button class="btn" id="closeLog">Close</button>
    </div>
  </div>

  <!-- API key prompt -->
  <div class="modal-overlay" id="tokenModalOverlay">
    <div class="modal">
      <h3>GitHub API key</h3>
      <div class="row">
        <label>API key</label>
        <input type="password" id="tokenModalInput" placeholder="ghp_..." />
        <button class="btn success" id="tokenModalSet">Continue</button>
      </div>
    </div>
  </div>

  <!-- Import M3U modal -->
  <div class="modal-overlay" id="importModalOverlay">
    <div class="modal">
      <h3>Import M3U</h3>
      <div class="row">
        <label>From URL</label>
        <input type="url" id="m3uUrl" placeholder="https://example.com/playlist.m3u8" />
        <button class="btn" id="fetchM3uUrlBtn">Import</button>
      </div>
      <div class="row">
        <label>From File</label>
        <input type="file" id="m3uFile" accept=".m3u,.m3u8,text/plain" />
        <button class="btn" id="importM3uFileBtn">Import</button>
      </div>
      <button class="btn" id="closeImportModal">Close</button>
    </div>
  </div>

  <!-- Delete confirmation modal -->
  <div class="modal-overlay" id="deleteModalOverlay">
    <div class="modal">
      <h3>Confirm deletion</h3>
      <p id="deleteMessage"></p>
      <div class="footer-actions">
        <button class="btn" id="cancelDelete">Cancel</button>
        <button class="btn danger" id="confirmDelete">Delete</button>
      </div>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const fixedConfig = {
    owner: 'cwdiptvb',
    repo: 'cwdiptvb.github.io',
    path: 'admin/channel.json',
    branch: 'main',
    catalogUrl: 'https://cwdiptvb.github.io/admin/channel.json'
  };

  const state = { channels: [], selected: new Set(), token: null };

  const el = {
    // Main controls
    cards: document.getElementById('cards'),
    loadBtn: document.getElementById('loadBtn'),
    saveBtn: document.getElementById('saveBtn'),
    batchBtn: document.getElementById('batchBtn'),
    addBtn: document.getElementById('addBtn'),
    deleteBtn: document.getElementById('deleteBtn'),
    selectAllBtn: document.getElementById('selectAllBtn'),

    // API key modal
    tokenModalOverlay: document.getElementById('tokenModalOverlay'),
    tokenModalInput: document.getElementById('tokenModalInput'),
    tokenModalSet: document.getElementById('tokenModalSet'),

    // Import modal
    importBtn: document.getElementById('importBtn'),
    importModalOverlay: document.getElementById('importModalOverlay'),
    closeImportModal: document.getElementById('closeImportModal'),
    fetchM3uUrlBtn: document.getElementById('fetchM3uUrlBtn'),
    m3uUrl: document.getElementById('m3uUrl'),
    m3uFile: document.getElementById('m3uFile'),
    importM3uFileBtn: document.getElementById('importM3uFileBtn'),

    // Delete modal
    deleteModalOverlay: document.getElementById('deleteModalOverlay'),
    deleteMessage: document.getElementById('deleteMessage'),
    cancelDelete: document.getElementById('cancelDelete'),
    confirmDelete: document.getElementById('confirmDelete'),

    // Batch modal
    batchModalOverlay: document.getElementById('batchModalOverlay'),
    closeBatchModal: document.getElementById('closeBatchModal'),
    batchProxyOn: document.getElementById('batchProxyOn'),

    // Log overlay
    logOverlay: document.getElementById('logOverlay'),
    logPre: document.getElementById('logPre'),
    closeLog: document.getElementById('closeLog')
  };

  // Cache helpers
  function saveCache(){ localStorage.setItem('channelEditorCache', JSON.stringify(state.channels)); }
  function loadCache(){ const c = localStorage.getItem('channelEditorCache'); if(c){ try{ state.channels = JSON.parse(c); return true; }catch{} } return false; }
  function clearCache(){ localStorage.removeItem('channelEditorCache'); }

  // UI helpers
  function updateSelectAllButton(){
    const total = state.channels.length, sel = state.selected.size;
    if(sel === 0) el.selectAllBtn.textContent = 'Select: ☐';
    else if(sel === total) el.selectAllBtn.textContent = 'Select: ☑';
    else el.selectAllBtn.textContent = 'Select: ▭';
  }

  // Load catalog from GitHub
  async function loadCatalog(){
    try{
      const res = await fetch(fixedConfig.catalogUrl,{cache:'no-store'});
      if (!res.ok) throw new Error('HTTP '+res.status);
      const data = await res.json();
      state.channels = Array.isArray(data)?data:[data];
      state.channels.forEach(c=>{
        c._enabled = c._enabled || {};
        ['name','id','url','codecs','bdwh','bdwhavg','fps'].forEach(k=>{
          if(c[k]!==undefined) c._enabled[k]=true;
        });
        if(c.proxy===undefined) c.proxy=false;
      });
      renderCards(); saveCache();
    }catch(err){ alert('Failed to load: '+err.message); }
  }

  // Render cards
  function renderCards(){
    el.cards.innerHTML='';
    state.channels.forEach((c,idx)=>{
      const card=document.createElement('div');
      card.className='card'+(state.selected.has(idx)?' selected':'')+(c.proxy?' proxy-on':'');
      card.dataset.index=idx;

      const top=document.createElement('div'); top.className='top';
      const select=document.createElement('input'); select.type='checkbox'; select.checked=state.selected.has(idx);
      select.addEventListener('change',()=>{ if(select.checked) state.selected.add(idx); else state.selected.delete(idx); renderCards(); });

      const title=document.createElement('div'); title.innerHTML=`<strong>${c.name||'(untitled)'}</strong>`;
      const badge=document.createElement('span'); badge.className='badge'; badge.textContent=c.proxy?'Proxy:ON':'Proxy:OFF';
      top.appendChild(select); top.appendChild(title); top.appendChild(badge); card.appendChild(top);

      const grid=document.createElement('div'); grid.className='grid';
      function makeRow(label,key,type='text'){
        const row=document.createElement('div'); row.className='row';
        const lb=document.createElement('label'); lb.className='checkbox';
        lb.innerHTML=`<input type="checkbox" ${c._enabled?.[key]?'checked':''}/> ${label}`;
        const input=document.createElement('input'); input.type=type; input.value=c[key]??'';
        const apply=document.createElement('button'); apply.className='btn'; apply.textContent='Apply';
        apply.addEventListener('click',()=>{
          const enabled=lb.querySelector('input').checked;
          c._enabled=c._enabled||{}; c._enabled[key]=enabled;
          if(enabled){ c[key]=type==='number'?Number(input.value):input.value; } else { delete c[key]; }
          saveCache(); renderCards();
        });
        row.appendChild(lb); row.appendChild(input); row.appendChild(apply);
        return row;
      }

      grid.appendChild(makeRow('Title','name'));
      grid.appendChild(makeRow('ID','id'));
      grid.appendChild(makeRow('URL','url','url'));
      grid.appendChild(makeRow('Bandwidth','bdwh','number'));
      grid.appendChild(makeRow('Avg bandwidth','bdwhavg','number'));
      grid.appendChild(makeRow('Frame rate','fps','number'));

      const proxyRow=document.createElement('div'); proxyRow.className='row';
      proxyRow.innerHTML=`<label class="checkbox"><input type="checkbox" ${c.proxy?'checked':''}/> Proxy</label><span></span><button class="btn">Apply</button>`;
      proxyRow.querySelector('button').addEventListener('click',()=>{
        c.proxy=proxyRow.querySelector('input').checked;
        saveCache(); renderCards();
      });
      grid.appendChild(proxyRow);

      card.appendChild(grid);
      el.cards.appendChild(card);
    });

    el.deleteBtn.disabled = state.selected.size === 0;
    el.batchBtn.disabled = state.selected.size < 2;
    updateSelectAllButton();
  }

  // Select all toggle
  el.selectAllBtn.addEventListener('click',()=>{
    const total=state.channels.length, sel=state.selected.size;
    if(sel<total) state.selected=new Set(state.channels.map((_,i)=>i));
    else state.selected.clear();
    renderCards();
  });

  // Proxy cleanup helper
  function cleanUrl(u){
    const prefix = "https://hlsr.vercel.app/api/proxy?url=";
    if(u.startsWith(prefix)){
      return { url: u.slice(prefix.length), proxy: true };
    }
    return { url: u, proxy: u.startsWith('http://') };
  }

  // M3U parser
  function parseM3U(text, sourceUrl) {
    const lines = text.split(/\r?\n/);
    const out = [];
    const base = (() => { try { return sourceUrl ? new URL(sourceUrl) : null; } catch { return null; } })();
    function resolveUrl(u){ if(!u) return ''; if(base){ try{ return new URL(u, base).toString(); }catch{} } return u; }
    function parseAttrs(attrStr){
      const attrs={};
      attrStr.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).forEach(part=>{
        const m=part.trim().match(/([A-Z0-9\-]+)=(.*)/);
        if(m){ let v=m[2].trim(); if(v.startsWith('"')&&v.endsWith('"')) v=v.slice(1,-1); attrs[m[1]]=v; }
      });
      return attrs;
    }
    let lastExtinfTitle=null;
    for(let i=0;i<lines.length;i++){
      const line=lines[i].trim(); if(!line) continue;
      if(line.startsWith('#EXT-X-STREAM-INF')){
        const attrs=parseAttrs(line.split(':')[1]||'');
        let variantUrl=''; for(let j=i+1;j<lines.length;j++){ const nxt=lines[j].trim(); if(!nxt||nxt.startsWith('#')) continue; variantUrl=resolveUrl(nxt); i=j; break; }
        if(!variantUrl) continue;
        const cleaned=cleanUrl(variantUrl);
        const name=attrs.NAME||lastExtinfTitle||cleaned.url;
        out.push({
          name,
          id:name.toLowerCase().replace(/[^a-z0-9]+/g,'-'),
          url: cleaned.url,
          bdwh: attrs.BANDWIDTH ? Number(attrs.BANDWIDTH) : undefined,
          bdwhavg: attrs['AVERAGE-BANDWIDTH'] ? Number(attrs['AVERAGE-BANDWIDTH']) : undefined,
          fps: attrs['FRAME-RATE'] ? Number(attrs['FRAME-RATE']) : undefined,
          codecs: attrs.CODECS,
          proxy: cleaned.proxy,
          _enabled:{name:true,id:true,url:true}
        });
        continue;
      }
      if(line.startsWith('#EXTINF')){
        const m=line.match(/#EXTINF:[^,]*,(.*)$/);
        lastExtinfTitle=m?m[1].trim():lastExtinfTitle;
        continue;
      }
      if(!line.startsWith('#') && (line.startsWith('http://') || line.startsWith('https://'))){
        const cleaned=cleanUrl(resolveUrl(line));
        const name=lastExtinfTitle||cleaned.url;
        out.push({
          name,
          id:name.toLowerCase().replace(/[^a-z0-9]+/g,'-'),
          url: cleaned.url,
          proxy: cleaned.proxy,
          _enabled:{name:true,id:true,url:true}
        });
        lastExtinfTitle=null;
      }
    }
    return out;
  }

  // Import modal
  el.importBtn.addEventListener('click', () => {
    el.importModalOverlay.style.display = 'flex';
  });
  el.closeImportModal.addEventListener('click', () => {
    el.importModalOverlay.style.display = 'none';
  });

  // Import from URL
  el.fetchM3uUrlBtn.addEventListener('click', async () => {
    const url = el.m3uUrl.value.trim();
    if (!url) return alert('Enter M3U URL');
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error('Fetch failed: ' + res.status);
      const text = await res.text();
      const imported = parseM3U(text, url);
      if (imported.length === 0) return alert('No streams found');
      state.channels = state.channels.concat(imported);
      saveCache();
      renderCards();
      el.importModalOverlay.style.display = 'none';
    } catch (err) {
      alert('Import failed: ' + err.message);
    }
  });

  // Import from file
  el.importM3uFileBtn.addEventListener('click', async () => {
    const file = el.m3uFile.files[0];
    if (!file) return alert('Choose a file');
    const text = await file.text();
    const imported = parseM3U(text, null);
    if (imported.length === 0) return alert('No streams found');
    state.channels = state.channels.concat(imported);
    saveCache();
    renderCards();
    el.importModalOverlay.style.display = 'none';
  });

  // Delete modal
  el.deleteBtn.addEventListener('click', () => {
    const names = Array.from(state.selected).map(i => state.channels[i].name || state.channels[i].id || '(unnamed)');
    el.deleteMessage.textContent = 'Are you sure you want to delete? Selected Channels: ' + names.join(', ');
    el.deleteModalOverlay.style.display = 'flex';
  });
  el.cancelDelete.addEventListener('click', () => {
    el.deleteModalOverlay.style.display = 'none';
  });
  el.confirmDelete.addEventListener('click', () => {
    state.channels = state.channels.filter((_, i) => !state.selected.has(i));
    state.selected.clear();
    saveCache();
    renderCards();
    el.deleteModalOverlay.style.display = 'none';
  });

  // Batch modal
  el.batchBtn.addEventListener('click', () => {
    if(state.selected.size < 2) return;
    el.batchModalOverlay.style.display = 'flex';
  });
  el.closeBatchModal.addEventListener('click', () => {
    el.batchModalOverlay.style.display = 'none';
  });
  el.batchProxyOn.addEventListener('click', () => {
    state.selected.forEach(i => { state.channels[i].proxy = true; });
    saveCache(); renderCards();
    el.batchModalOverlay.style.display = 'none';
  });

  // Log overlay
  function logStep(msg){ el.logPre.textContent += msg + '\n'; }
  function showLog(){ el.logOverlay.style.display = 'flex'; el.logPre.textContent = ''; }
  el.closeLog.addEventListener('click', () => { el.logOverlay.style.display = 'none'; });

  // Save to GitHub
  el.saveBtn.addEventListener('click', async () => {
    if (!state.token) return alert('API key required');
    showLog();
    logStep('Saving to GitHub...');
    try {
      const content = new TextEncoder().encode(JSON.stringify(state.channels, null, 2));
      const base64 = btoa(String.fromCharCode(...content));
      const body = {
        message: `Update ${fixedConfig.path}`,
        content: base64,
        branch: fixedConfig.branch
      };

      // Get current file SHA
      try {
        const shaRes = await fetch(
          `https://api.github.com/repos/${fixedConfig.owner}/${fixedConfig.repo}/contents/${fixedConfig.path}?ref=${fixedConfig.branch}`,
          { headers: { Authorization: `Bearer ${state.token}` } }
        );
        if (shaRes.status === 200) {
          const info = await shaRes.json();
          body.sha = info.sha;
          logStep('Found existing file SHA: ' + info.sha);
        } else if (shaRes.status === 404) {
          logStep('File does not exist. A new file will be created.');
        } else {
          const t = await shaRes.text();
          throw new Error('Failed to get SHA: ' + shaRes.status + ' ' + t);
        }
      } catch (e) {
        logStep('Warning: could not fetch SHA. Proceeding anyway. ' + e.message);
      }

      const res = await fetch(
        `https://api.github.com/repos/${fixedConfig.owner}/${fixedConfig.repo}/contents/${fixedConfig.path}`,
        {
          method: 'PUT',
          headers: {
            Authorization: `Bearer ${state.token}`,
            'Content-Type': 'application/json',
            'Accept': 'application/vnd.github+json'
          },
          body: JSON.stringify(body)
        }
      );
      const data = await res.json();
      if (!res.ok) throw new Error('Commit failed: ' + JSON.stringify(data));
      logStep('Commit successful: ' + (data.commit?.sha || '(no sha)'));
      clearCache();
      logStep('Local cache cleared.');
      setTimeout(() => {
        if (confirm('Commit succeeded. Open catalog JSON?')) {
          window.location.href = fixedConfig.catalogUrl;
        }
      }, 300);
    } catch (err) {
      logStep('ERROR: ' + err.message);
    }
  });

  // Token prompt and boot
  el.tokenModalSet.addEventListener('click', () => {
    const token = el.tokenModalInput.value.trim();
    if (!token) return alert('API key required.');
    state.token = token;
    el.tokenModalOverlay.style.display = 'none';
    el.saveBtn.disabled = false;

    if (!loadCache()) {
      loadCatalog();
    } else {
      renderCards();
    }
  });

  // Boot sequence: prefer cache, else GitHub, then prompt for API key
  const hadCache = loadCache();
  if (hadCache) {
    renderCards();
  } else {
    loadCatalog();
  }
  if (!state.token) {
    el.tokenModalOverlay.style.display = 'flex';
  }

  // Optional quick add
  if (el.addBtn) {
    el.addBtn.addEventListener('click', () => {
      const name = prompt('Channel title:') || '';
      const id = prompt('Channel ID (leave blank to auto):') || '';
      const url = prompt('Stream URL:') || '';
      if (!name || !url) return;
      const cleaned = cleanUrl(url);
      const c = {
        name,
        id: id || name.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'').slice(0,64),
        url: cleaned.url,
        proxy: cleaned.proxy,
        _enabled: { name: true, id: true, url: true }
      };
      state.channels.push(c);
      saveCache();
      renderCards();
    });
  }

  // Reload button prefers cache
  el.loadBtn.addEventListener('click', () => {
    if (!loadCache()) loadCatalog();
    else renderCards();
  });
});
</script>
</body>
</html>
