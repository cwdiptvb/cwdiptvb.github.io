<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Free Live TV - Watch Free Online Channels</title>
  <link rel="icon" href="/fav/16.png" sizes="16x16">
  <link rel="icon" href="/fav/32.png" sizes="32x32">
  <link href="https://fonts.googleapis.com/css?family=Lato:400,600,700&display=swap" rel="stylesheet">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
  
  <style>
    html, body {
      margin: 0;
      height: 100%;
      font-family: 'Lato', 'Segoe UI', sans-serif;
      background-color: #0d0d0d;
      color: #f2f2f2;
      display: flex;
      flex-direction: column;
    }
    header {
      background-color: #1a1a1a;
      padding: 1rem 2rem;
      border-bottom: 2px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }
    header a {
      text-decoration: none;
      color: inherit;
    }
    header h1 {
      margin: 0;
      font-size: 2rem;
      color: #00ffff;
      font-weight: 700;
    }
    nav {
      display: flex;
      gap: 1rem;
    }
    nav a {
      color: #f2f2f2;
      text-decoration: none;
      font-weight: 600;
    }
    nav a:hover {
      color: #00ffff;
    }
    main {
      flex: 1;
      padding: 2rem 10%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h2 {
      font-size: 1.8rem;
      color: #00ffff;
      margin-bottom: 2rem;
      width: 100%;
      max-width: 1200px;
      text-align: center;
    }
    
    /* Channel Grid and Card Styling */
    #channel-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      width: 100%;
      max-width: 1200px;
      padding-bottom: 2rem;
    }
    .channel-card {
      background-color: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 1rem;
      text-decoration: none;
      color: inherit;
      transition: border-color 0.3s, background-color 0.3s;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    }
    .channel-card:hover {
      border-color: #00ffff;
      background-color: #252525;
      transform: translateY(-2px);
    }
    .channel-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.75rem;
    }
    .channel-logo {
      width: 48px;
      height: 48px;
      object-fit: contain;
      margin-right: 1rem;
      border-radius: 4px;
      background-color: #000;
      border: 1px solid #444;
      flex-shrink: 0;
    }
    .channel-name {
      font-size: 1.25rem;
      font-weight: 700;
      color: #f2f2f2;
      line-height: 1.2;
    }
    .channel-category {
      font-size: 0.8rem;
      color: #888;
      font-weight: 600;
      margin-top: 0.25rem;
    }
    .channel-program {
      padding-top: 0.75rem;
      border-top: 1px solid #333;
      font-size: 0.95rem;
    }
    .channel-program strong {
      display: block;
      color: #00ffff;
      font-weight: 600;
    }
    .program-time {
      font-size: 0.85rem;
      color: #aaa;
      margin-top: 0.25rem;
    }
    
    /* Loading and Playlist Card */
    #loading-message {
      text-align: center;
      padding: 3rem;
      font-size: 1.2rem;
      color: #00ffff;
    }
    .playlist-card {
      display: flex;
      align-items: center;
      background-color: #1a1a1a;
      border: 2px solid #333;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      text-decoration: none;
      color: inherit;
      transition: border-color 0.3s;
      width: 100%;
      max-width: 800px;
      margin-top: 1rem;
    }
    .playlist-card:hover {
      border-color: #00ffff;
    }
    .playlist-card img {
      width: 48px;
      height: 48px;
      object-fit: contain;
      margin-right: 1rem;
      border-radius: 4px;
      background-color: #000;
    }
    .playlist-label {
      font-size: 1.1rem;
      font-weight: 600;
      flex-grow: 1;
    }
    .playlist-label small {
      display: block;
      color: #888;
      font-size: 0.85rem;
      margin-top: 0.25rem;
    }
    .copy-btn {
      margin-left: auto;
      background-color: #00ffff;
      border: none;
      color: #000;
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
    }

    footer {
      text-align: center;
      padding: 1rem;
      background-color: #1a1a1a;
      border-top: 2px solid #333;
      font-size: 0.9rem;
      color: #888;
    }

    @media (max-width: 768px) {
      main {
        padding: 1rem 5%;
      }
      #channel-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <a href="/"><h1>Free Live TV</h1></a>
    <nav>
      <a href="/">Home</a>
      <a href="/contact">Contact</a>
      <a href="/about">About</a>
    </nav>
  </header>
  <main>
    <h2>Live Channel Guide</h2>

    <div id="loading-message">Loading channel data and TV schedule...</div>
    
    <div id="channel-grid">
      </div>

    <div class="playlist-card">
      <img src="https://cdn-icons-png.flaticon.com/512/10260/10260622.png" alt="icon" />
      <div class="playlist-label">
        Free M3U Playlist
        <small>https://cwdiptvb.github.io/tv_channels.m3u</small>
      </div>
      <button class="copy-btn" onclick="copyPlaylistURL()">Copy</button>
    </div>
  </main>
  <footer>
    &copy; 2025 Free Live TV. All rights reserved.
  </footer>

  <script>
    const M3U_URL = "https://cwdiptvb.github.io/tv_channels.m3u";
    const XMLTV_URL = "https://cwdiptvb-github-io.onrender.com/m3usch";
    
    let CHANNEL_DATA = [];
    let EPG_DATA = {}; // Stores all programs grouped by channel ID

    function copyPlaylistURL() {
      navigator.clipboard.writeText(M3U_URL).then(() => {
        alert("Playlist URL copied to clipboard!");
      }).catch(err => {
        alert("Failed to copy URL.");
      });
    }

    // --- EPG Utility Functions (Copied from player.html for consistency) ---

    // Function to handle the *incorrectly formatted* XMLTV date string
    const parseXmlTvDateFix = (dateStr) => {
      const cleanDigits = dateStr.substring(0, 14);

      if (cleanDigits.length !== 14) return new Date(NaN);

      const year = cleanDigits.substring(0, 4);
      const month = cleanDigits.substring(4, 6);
      const day = cleanDigits.substring(6, 8);
      const hour = cleanDigits.substring(8, 10);
      const minute = cleanDigits.substring(10, 12);
      const second = cleanDigits.substring(12, 14);
      
      const isoString = `${year}-${month}-${day}T${hour}:${minute}:${second}.000Z`;
      return new Date(isoString);
    };

    // --- Data Fetching Functions ---

    async function fetchM3UData() {
        try {
            const response = await fetch(M3U_URL);
            if (!response.ok) throw new Error("Failed to fetch M3U file");
            const data = await response.text();
            const lines = data.split(/\r?\n/);
            
            let currentChannel = {};

            for (let i = 0; i < lines.length; i++) {
                if (lines[i].startsWith("#EXTINF")) {
                    // Extract tvg-id, logo, and group-title
                    const idMatch = lines[i].match(/tvg-id="([^"]+)"/i);
                    const logoMatch = lines[i].match(/tvg-logo="([^"]+)"/i);
                    const categoryMatch = lines[i].match(/group-title="([^"]+)"/i);
                    
                    currentChannel.id = idMatch ? idMatch[1] : null;
                    currentChannel.logo = logoMatch ? logoMatch[1] : '';
                    currentChannel.category = categoryMatch ? categoryMatch[1] : 'Uncategorized';
                    
                    // Extract channel name (the text after the last comma)
                    const nameMatch = lines[i].match(/,([^,]+)$/);
                    currentChannel.name = nameMatch ? nameMatch[1].trim() : 'Unknown Channel';

                } else if (lines[i].startsWith("http") && currentChannel.id) {
                    currentChannel.url = lines[i].trim();
                    CHANNEL_DATA.push(currentChannel);
                    currentChannel = {}; // Reset for the next channel
                }
            }
            console.log(`✅ Loaded ${CHANNEL_DATA.length} channels from M3U.`);
        } catch (error) {
            console.error("❌ Error fetching M3U data:", error);
            $("#loading-message").text("Error: Failed to load channel list.");
        }
    }

    async function fetchXMLTVData() {
        try {
            const res = await fetch(XMLTV_URL);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            let xmlText = await res.text();
            
            const safeXmlText = xmlText.replace(/&(?!(?:apos|quot|[gl]t|amp);)/g, '&amp;');

            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(safeXmlText, "text/xml");
            
            const errorNode = xmlDoc.querySelector('parsererror');
            if (errorNode) {
                console.error("XML Parsing Failed:", errorNode.textContent);
                throw new Error("XML Parsing Failed");
            }

            const programElements = xmlDoc.querySelectorAll('programme');
            programElements.forEach(program => {
                const channelId = program.getAttribute('channel');
                if (!channelId) return;

                const startStr = program.getAttribute('start');
                const stopStr = program.getAttribute('stop'); 
                
                // Use the fix function to parse the broken server output
                const startUTC = parseXmlTvDateFix(startStr);
                const stopUTC = parseXmlTvDateFix(stopStr);

                // Skip if date is invalid
                if (isNaN(startUTC.getTime()) || isNaN(stopUTC.getTime())) return;
                
                const title = program.querySelector('title')?.textContent || "Untitled Program";
                const subtitle = program.querySelector('sub-title')?.textContent;
                
                if (!EPG_DATA[channelId]) {
                    EPG_DATA[channelId] = [];
                }
                
                EPG_DATA[channelId].push({
                    start: startUTC,
                    stop: stopUTC,
                    title: title,
                    subtitle: subtitle
                });
            });

            console.log(`✅ Loaded EPG data for ${Object.keys(EPG_DATA).length} channels.`);
        } catch (error) {
            console.error("❌ Error fetching XMLTV data:", error);
            // Non-critical error, log and continue, but flag it.
            EPG_DATA.error = true;
        }
    }

    function getCurrentProgram(tvgId) {
        const programs = EPG_DATA[tvgId];
        const now = new Date();

        if (!programs) {
            return { title: 'No EPG data available.', time: '' };
        }

        // Find the program where start <= now < stop
        const currentProgram = programs.find(p => p.start <= now && p.stop > now);

        if (currentProgram) {
            const localStartTime = currentProgram.start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const localStopTime = currentProgram.stop.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            let fullTitle = currentProgram.title;
            if (currentProgram.subtitle) {
                fullTitle += `: ${currentProgram.subtitle}`;
            }

            return {
                title: fullTitle,
                time: `${localStartTime} - ${localStopTime}`
            };
        }

        // If no program is currently running, find the next one
        const nextPrograms = programs.filter(p => p.start > now).sort((a, b) => a.start - b.start);
        
        if (nextPrograms.length > 0) {
            const nextProgram = nextPrograms[0];
            const localStartTime = nextProgram.start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            return {
                title: nextProgram.title,
                time: `Next at ${localStartTime}`
            };
        }

        return { title: 'Schedule TBD.', time: '' };
    }

    function renderChannels() {
        const grid = $("#channel-grid");
        grid.empty();
        
        // Group channels by category
        const categorizedChannels = CHANNEL_DATA.reduce((acc, channel) => {
            const category = channel.category || 'Other';
            if (!acc[category]) {
                acc[category] = [];
            }
            acc[category].push(channel);
            return acc;
        }, {});
        
        // Determine the order (optional, but good for consistency)
        const categoryOrder = ['News', 'Sports', 'Entertainment', 'Kids', 'Music', 'Other', 'Uncategorized'];
        const sortedCategories = Object.keys(categorizedChannels).sort((a, b) => {
            const indexA = categoryOrder.indexOf(a);
            const indexB = categoryOrder.indexOf(b);
            if (indexA === -1 && indexB === -1) return a.localeCompare(b);
            if (indexA === -1) return 1;
            if (indexB === -1) return -1;
            return indexA - indexB;
        });

        sortedCategories.forEach(category => {
            const categoryHeader = $(`<h3 style="grid-column: 1 / -1; color:#f2f2f2; margin-top:1.5rem; border-bottom: 2px solid #00ffff; padding-bottom: 0.5rem;">${category}</h3>`);
            grid.append(categoryHeader);
            
            categorizedChannels[category].forEach(channel => {
                const program = getCurrentProgram(channel.id);

                const cardHtml = `
                    <a href="/play.html?id=${channel.id}" class="channel-card">
                        <div class="channel-header">
                            <img src="${channel.logo}" alt="${channel.name} Logo" class="channel-logo" onerror="this.onerror=null;this.src='/placeholder.png';">
                            <div>
                                <div class="channel-name">${channel.name}</div>
                                <div class="channel-category">${channel.category}</div>
                            </div>
                        </div>
                        <div class="channel-program">
                            <strong>${program.title}</strong>
                            <span class="program-time">${program.time}</span>
                        </div>
                    </a>
                `;
                grid.append(cardHtml);
            });
        });

        // Remove loading message
        $("#loading-message").remove();
    }


    // --- Initialization ---

    $(document).ready(async function () {
        // 1. Fetch data concurrently
        await Promise.all([
            fetchM3UData(),
            fetchXMLTVData()
        ]);

        // 2. Render the grid
        if (CHANNEL_DATA.length > 0) {
            renderChannels();
        } else {
             $("#loading-message").text("Fatal Error: Could not load any channel data.");
        }
    });
  </script>
</body>
</html>
