<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Free Live TV - Watch Free Online Channels</title>
  <link rel="icon" href="/fav/16.png" sizes="16x16">
  <link rel="icon" href="/fav/32.png" sizes="32x32">
  <link rel="icon" href="/fav/48.png" sizes="48x48">
  <link rel="icon" type="image/png" sizes="192x192" href="/fav/192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="/fav/512.png">
  <link rel="apple-touch-icon" href="fav/180.png" sizes="/180x180">
  <link href="https://fonts.googleapis.com/css?family=Lato:400,600,700&display=swap" rel="stylesheet">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
  
  <style>
    html, body {
      margin: 0;
      height: 100%;
      font-family: 'Lato', 'Segoe UI', sans-serif;
      background-color: #0d0d0d;
      color: #f2f2f2;
      display: flex;
      flex-direction: column;
    }
    header {
      background-color: #1a1a1a;
      padding: 1rem 2rem;
      border-bottom: 2px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }
    header a {
      text-decoration: none;
      color: inherit;
    }
    header h1 {
      margin: 0;
      font-size: 2rem;
      color: #00ffff;
      font-weight: 700;
    }
    nav {
      display: flex;
      gap: 1rem;
    }
    nav a {
      color: #f2f2f2;
      text-decoration: none;
      font-weight: 600;
    }
    nav a:hover {
      color: #00ffff;
    }
    main {
      flex: 1;
      padding: 2rem 10%;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      box-sizing: border-box;
    }
    h2 {
      font-size: 1.8rem;
      color: #00ffff;
      margin-bottom: 2rem;
      width: 100%;
      max-width: 1200px;
      text-align: center;
    }
    
    /* Filtering and Search Area */
    #filter-area {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 1200px;
      margin-bottom: 1.5rem;
      gap: 1rem;
    }
    #category-filter, #search-input {
      padding: 0.75rem 1rem;
      border-radius: 6px;
      border: 1px solid #333;
      background-color: #1a1a1a;
      color: #f2f2f2;
      font-size: 1rem;
      outline: none;
      transition: border-color 0.3s;
      height: 44px; /* Standardize height */
    }
    #category-filter {
      flex: 1;
      max-width: 300px;
      appearance: none; /* Hide default select arrow */
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="%2300ffff"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>');
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      background-size: 1.5em;
    }
    #search-input {
      flex: 2;
    }
    #category-filter:focus, #search-input:focus {
        border-color: #00ffff;
    }

    /* Channel Grid and Card Styling (restored layout) */
    #channel-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      width: 100%;
      max-width: 1200px;
      padding-bottom: 2rem;
    }
    .channel-card {
      background-color: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 1rem;
      text-decoration: none;
      color: inherit;
      transition: border-color 0.3s, background-color 0.3s;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    }
    .channel-card:hover {
      border-color: #00ffff;
      background-color: #252525;
      transform: translateY(-2px);
    }
    .channel-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.75rem;
    }
    .channel-logo {
      width: 48px;
      height: 48px;
      object-fit: contain;
      margin-right: 1rem;
      border-radius: 4px;
      background-color: #000;
      border: 1px solid #444;
      flex-shrink: 0;
    }
    .channel-info {
        flex-grow: 1;
        min-width: 0; /* Prevents overflow */
    }
    .channel-name {
      font-size: 1.25rem;
      font-weight: 700;
      color: #f2f2f2;
      line-height: 1.2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .channel-category {
      font-size: 0.8rem;
      color: #888;
      font-weight: 600;
      margin-top: 0.25rem;
    }
    .channel-program {
      padding-top: 0.75rem;
      border-top: 1px solid #333;
      font-size: 0.95rem;
    }
    .channel-program strong {
      display: block;
      color: #00ffff;
      font-weight: 600;
    }
    .program-time {
      font-size: 0.85rem;
      color: #aaa;
      margin-top: 0.25rem;
    }
    
    /* Loading and Playlist Card */
    #loading-message, #no-results {
      text-align: center;
      padding: 3rem;
      font-size: 1.2rem;
      color: #00ffff;
      width: 100%;
    }
    #no-results {
        display: none;
        color: #ff3333;
    }
    .playlist-card {
      /* ... (styles remain the same) ... */
      display: flex;
      align-items: center;
      background-color: #1a1a1a;
      border: 2px solid #333;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      text-decoration: none;
      color: inherit;
      transition: border-color 0.3s;
      width: 100%;
      max-width: 800px;
      margin-top: 1rem;
    }
    .playlist-card:hover {
      border-color: #00ffff;
    }
    .playlist-card img {
      width: 48px;
      height: 48px;
      object-fit: contain;
      margin-right: 1rem;
      border-radius: 4px;
      background-color: #000;
    }
    .playlist-label {
      font-size: 1.1rem;
      font-weight: 600;
      flex-grow: 1;
    }
    .playlist-label small {
      display: block;
      color: #888;
      font-size: 0.85rem;
      margin-top: 0.25rem;
    }
    .copy-btn {
      margin-left: auto;
      background-color: #00ffff;
      border: none;
      color: #000;
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
    }

    footer {
      text-align: center;
      padding: 1rem;
      background-color: #1a1a1a;
      border-top: 2px solid #333;
      font-size: 0.9rem;
      color: #888;
    }

    @media (max-width: 768px) {
      main {
        padding: 1rem 5%;
      }
      #channel-grid {
        grid-template-columns: 1fr;
      }
      #filter-area {
        flex-direction: column;
        gap: 0.75rem;
      }
      #category-filter, #search-input {
        max-width: 100%;
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <header>
    <a href="/"><h1>Free Live TV</h1></a>
    <nav>
      <a href="/">Home</a>
      <a href="/contact">Contact</a>
      <a href="/about">About</a>
    </nav>
  </header>
  <main>
    <h2>Live Channel Guide</h2>

    <div id="filter-area">
        <select id="category-filter">
            <option value="All">All Categories</option>
        </select>
        <input type="text" id="search-input" placeholder="Search channels..." />
    </div>

    <div id="loading-message">Loading channel data and TV schedule...</div>
    <div id="no-results" style="display: none;">No channels found matching your filters.</div>
    
    <div id="channel-grid">
      </div>

    <div class="playlist-card">
      <img src="https://cdn-icons-png.flaticon.com/512/10260/10260622.png" alt="icon" />
      <div class="playlist-label">
        Free M3U Playlist
        <small>https://cwdiptvb.github.io/tv_channels.m3u</small>
      </div>
      <button class="copy-btn" onclick="copyPlaylistURL()">Copy</button>
    </div>
  </main>
  <footer>
    &copy; 2025 Free Live TV. All rights reserved.
  </footer>

  <script>
    const M3U_URL = "https://cwdiptvb.github.io/tv_channels.m3u";
    const XMLTV_URL = "https://cwdiptvb-github-io.onrender.com/m3usch";
    
    let CHANNEL_DATA = [];
    let EPG_DATA = {}; // Stores all programs grouped by channel ID
    let AVAILABLE_CATEGORIES = new Set();

    function copyPlaylistURL() {
      navigator.clipboard.writeText(M3U_URL).then(() => {
        alert("Playlist URL copied to clipboard!");
      }).catch(err => {
        alert("Failed to copy URL.");
      });
    }

    // --- EPG Utility Functions ---

    const parseXmlTvDateFix = (dateStr) => {
      const cleanDigits = dateStr.substring(0, 14);
      if (cleanDigits.length !== 14) return new Date(NaN);
      const year = cleanDigits.substring(0, 4);
      const month = cleanDigits.substring(4, 6);
      const day = cleanDigits.substring(6, 8);
      const hour = cleanDigits.substring(8, 10);
      const minute = cleanDigits.substring(10, 12);
      const second = cleanDigits.substring(12, 14);
      const isoString = `${year}-${month}-${day}T${hour}:${minute}:${second}.000Z`;
      return new Date(isoString);
    };

    // --- Data Fetching Functions ---

    async function fetchM3UData() {
        try {
            const response = await fetch(M3U_URL);
            if (!response.ok) throw new Error("Failed to fetch M3U file");
            const data = await response.text();
            const lines = data.split(/\r?\n/);
            
            let currentChannel = {};

            for (let i = 0; i < lines.length; i++) {
                if (lines[i].startsWith("#EXTINF")) {
                    const idMatch = lines[i].match(/tvg-id="([^"]+)"/i);
                    const logoMatch = lines[i].match(/tvg-logo="([^"]+)"/i);
                    const categoryMatch = lines[i].match(/group-title="([^"]+)"/i);
                    
                    currentChannel.id = idMatch ? idMatch[1] : null;
                    currentChannel.logo = logoMatch ? logoMatch[1] : '';
                    currentChannel.category = categoryMatch ? categoryMatch[1].trim() : 'Uncategorized';
                    
                    const nameMatch = lines[i].match(/,([^,]+)$/);
                    currentChannel.name = nameMatch ? nameMatch[1].trim() : 'Unknown Channel';

                } else if (lines[i].startsWith("http") && currentChannel.id) {
                    currentChannel.url = lines[i].trim();
                    CHANNEL_DATA.push(currentChannel);
                    AVAILABLE_CATEGORIES.add(currentChannel.category);
                    currentChannel = {}; // Reset for the next channel
                }
            }
            console.log(`✅ Loaded ${CHANNEL_DATA.length} channels from M3U.`);
        } catch (error) {
            console.error("❌ Error fetching M3U data:", error);
            $("#loading-message").text("Error: Failed to load channel list.");
        }
    }

    async function fetchXMLTVData() {
        try {
            const res = await fetch(XMLTV_URL);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            let xmlText = await res.text();
            
            const safeXmlText = xmlText.replace(/&(?!(?:apos|quot|[gl]t|amp);)/g, '&amp;');

            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(safeXmlText, "text/xml");
            
            const errorNode = xmlDoc.querySelector('parsererror');
            if (errorNode) throw new Error("XML Parsing Failed");

            const programElements = xmlDoc.querySelectorAll('programme');
            programElements.forEach(program => {
                const channelId = program.getAttribute('channel');
                if (!channelId) return;

                const startStr = program.getAttribute('start');
                const stopStr = program.getAttribute('stop'); 
                
                const startUTC = parseXmlTvDateFix(startStr);
                const stopUTC = parseXmlTvDateFix(stopStr);

                if (isNaN(startUTC.getTime()) || isNaN(stopUTC.getTime())) return;
                
                const title = program.querySelector('title')?.textContent || "Untitled Program";
                const subtitle = program.querySelector('sub-title')?.textContent;
                
                if (!EPG_DATA[channelId]) {
                    EPG_DATA[channelId] = [];
                }
                
                EPG_DATA[channelId].push({
                    start: startUTC,
                    stop: stopUTC,
                    title: title,
                    subtitle: subtitle
                });
            });

            // Sort programs for easy lookup
            Object.values(EPG_DATA).forEach(programs => {
                programs.sort((a, b) => a.start - b.start);
            });

            console.log(`✅ Loaded EPG data for ${Object.keys(EPG_DATA).length} channels.`);
        } catch (error) {
            console.error("❌ Error fetching XMLTV data:", error);
            EPG_DATA.error = true;
        }
    }

    function getCurrentProgram(tvgId) {
        const programs = EPG_DATA[tvgId];
        const now = new Date();

        if (!programs || programs.length === 0) {
            return { title: 'No EPG data available.', time: '' };
        }

        // Find the program where start <= now < stop
        const currentProgram = programs.find(p => p.start <= now && p.stop > now);

        if (currentProgram) {
            const localStartTime = currentProgram.start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const localStopTime = currentProgram.stop.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            let fullTitle = currentProgram.title;
            if (currentProgram.subtitle) {
                fullTitle += `: ${currentProgram.subtitle}`;
            }

            return {
                title: fullTitle,
                time: `${localStartTime} - ${localStopTime} (Now)`
            };
        }

        // If not running, find the next one
        const nextPrograms = programs.filter(p => p.start > now);
        
        if (nextPrograms.length > 0) {
            const nextProgram = nextPrograms[0];
            const localStartTime = nextProgram.start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            return {
                title: nextProgram.title,
                time: `Next at ${localStartTime}`
            };
        }

        return { title: 'Schedule TBD.', time: '' };
    }

    // --- Rendering and Filtering ---

    function renderChannels() {
        const grid = $("#channel-grid");
        const selectedCategory = $("#category-filter").val();
        const searchTerm = $("#search-input").val().toLowerCase();
        
        grid.empty();
        
        let filteredChannels = CHANNEL_DATA.filter(channel => {
            const matchesCategory = selectedCategory === 'All' || channel.category === selectedCategory;
            const matchesSearch = channel.name.toLowerCase().includes(searchTerm) || 
                                  channel.id.toLowerCase().includes(searchTerm);
            return matchesCategory && matchesSearch;
        });
        
        if (filteredChannels.length === 0) {
            $("#no-results").show();
            return;
        } else {
            $("#no-results").hide();
        }

        // Group channels by category for structured display
        const categorizedChannels = filteredChannels.reduce((acc, channel) => {
            const category = channel.category || 'Other';
            if (!acc[category]) {
                acc[category] = [];
            }
            acc[category].push(channel);
            return acc;
        }, {});
        
        // Define a sorting order for categories
        const categoryOrder = ['News', 'Sports', 'Entertainment', 'Kids', 'Music', 'Movies', 'Lifestyle', 'General', 'Other', 'Uncategorized'];
        const sortedCategories = Object.keys(categorizedChannels).sort((a, b) => {
            const indexA = categoryOrder.indexOf(a);
            const indexB = categoryOrder.indexOf(b);
            if (indexA === -1 && indexB === -1) return a.localeCompare(b);
            if (indexA === -1) return 1;
            if (indexB === -1) return -1;
            return indexA - indexB;
        });

        sortedCategories.forEach(category => {
            // Only show category headers if 'All' is selected or if we're not filtering by a single category
            if (selectedCategory === 'All' && category !== 'Uncategorized') {
                const categoryHeader = $(`<h3 style="grid-column: 1 / -1; color:#f2f2f2; margin-top:1.5rem; border-bottom: 2px solid #00ffff; padding-bottom: 0.5rem;">${category}</h3>`);
                grid.append(categoryHeader);
            }
            
            // Sort channels within the category alphabetically
            categorizedChannels[category].sort((a, b) => a.name.localeCompare(b.name));

            categorizedChannels[category].forEach(channel => {
                const program = getCurrentProgram(channel.id);
                // URL linking to /play?id={tvg-id} for the clean appearance
                const linkUrl = `/play?id=${channel.id}`; 

                const cardHtml = `
                    <a href="${linkUrl}" class="channel-card" data-tvg-id="${channel.id}" data-category="${channel.category}">
                        <div class="channel-header">
                            <img src="${channel.logo}" alt="${channel.name} Logo" class="channel-logo" onerror="this.onerror=null;this.src='/placeholder.png';">
                            <div class="channel-info">
                                <div class="channel-name">${channel.name}</div>
                                <div class="channel-category">${channel.category}</div>
                            </div>
                        </div>
                        <div class="channel-program">
                            <strong>${program.title}</strong>
                            <span class="program-time">${program.time}</span>
                        </div>
                    </a>
                `;
                grid.append(cardHtml);
            });
        });
    }
    
    function populateCategoryFilter() {
        const filter = $("#category-filter");
        
        // Sort categories alphabetically (after converting Set to Array)
        const sortedCategories = Array.from(AVAILABLE_CATEGORIES).sort();
        
        sortedCategories.forEach(category => {
            filter.append(`<option value="${category}">${category}</option>`);
        });

        // Attach event listeners for filtering
        filter.on('change', renderChannels);
        $("#search-input").on('keyup', renderChannels);
    }

    // --- Initialization ---

    $(document).ready(async function () {
        // 1. Fetch data concurrently
        await Promise.all([
            fetchM3UData(),
            fetchXMLTVData()
        ]);

        // 2. Handle errors/empty list
        if (CHANNEL_DATA.length === 0) {
             $("#loading-message").text("Fatal Error: Could not load any channel data.");
             return;
        }

        // 3. Populate filter and render initial grid
        populateCategoryFilter();
        renderChannels();

        // 4. Remove loading message
        $("#loading-message").remove();
        
        // Optional: Re-render every minute to update the "Now Playing" status
        setInterval(renderChannels, 60000); 
    });
  </script>
</body>
</html>
